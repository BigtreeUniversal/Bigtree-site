<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<title>Bubble Earth ‚Äî azimutale ‚áÑ Mercator (recentrage GPS)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet"/>
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<style>
  html,body{margin:0;height:100%;width:100%;background:#0a0f1a}
  #map{position:absolute;inset:0}
  #overlay{position:absolute;inset:0;pointer-events:auto}
  header{position:fixed;top:8px;left:8px;z-index:10;
    background:rgba(7,12,25,0.9);color:#fff;border-radius:10px;padding:8px 10px;
    font:14px/1.3 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;display:flex;gap:8px;align-items:center}
  select,button{background:#121826;color:#fff;border:1px solid #2b3245;border-radius:8px;padding:4px 6px}
  .pill{opacity:.8}
</style>
</head>
<body>
<header>
  <strong>üåç Bubble Earth</strong>
  <label>Imagerie :
    <select id="layerSel">
      <option value="osm">OSM</option>
      <option value="esri" selected>ESRI</option>
    </select>
  </label>
  <span id="dbg" class="pill"></span>
</header>

<div id="map"></div>
<canvas id="overlay"></canvas>

<script>
/* ========= CONFIG ========= */
// Ton image azimutale (Nord au centre). 1600√ó1600 px dans ton CSV.
const AZIMUTHAL_IMG_URL = 'assets/flat-earth-aeqd.jpg';
// CSV avec colonnes: latitude, longitude, x, y (pixels) ‚Äî centre image ~ (800,800)
const CSV_URL = 'assets/points_gps_azimutaux.csv';

// Fade/zoom : garde l‚Äôesprit de ta config
const FADE_OUT_AZ_START = 2, FADE_OUT_AZ_END = 5;   // l‚Äôazimutale s‚Äô√©teint
const FADE_IN_IM_START  = 3, FADE_IN_IM_END  = 6;   // l‚Äôimagerie appara√Æt
const RECENTER_TRIGGER_Z = 5.0; // √† partir de ce zoom, on recentre (au milieu du fade)

/* ========= SOURCES CARTO ========= */
const providers = {
  osm:  { tiles:['https://tile.openstreetmap.org/{z}/{x}/{y}.png'], tileSize:256, attribution:'¬© OpenStreetMap' },
  esri: { tiles:['https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'], tileSize:256, attribution:'Tiles ¬© Esri' }
};

// Limite d‚Äôaffichage Web Mercator
const MERC_MAX = 85.05113;

/* ========= CALIBRAGE AEQD (depuis CSV) ========= */
// Mod√®le: AEQD polaire Nord (œÜ0=+90¬∞). Pour un point (lon,lat):
//  colat = 90 - lat (en degr√©s) ; r = S * colat (pixels)
//  angle_image = lon - Œª0 (en degr√©s, 0¬∞ ¬´ en haut ¬ª)
//  x = cx + r * sin(angle) ; y = cy - r * cos(angle)

const calib = {
  width:1600, height:1600,
  cx:800, cy:800,
  S:3.2,              // pixels par degr√© (secours)
  lambda0:-15,        // degr√©s (secours)
  ready:false
};

// Parser CSV minimal (robuste, sans lib externe)
function parseCSV(text){
  const rows = text.trim().split(/\r?\n/).map(r=>r.split(',').map(s=>s.trim()));
  const header = rows.shift().map(h=>h.toLowerCase());
  const idx = Object.fromEntries(header.map((h,i)=>[h,i]));
  return rows.map(r=>({
    latitude:  parseFloat(r[idx['latitude']]),
    longitude: parseFloat(r[idx['longitude']]),
    x:         parseFloat(r[idx['x']]),
    y:         parseFloat(r[idx['y']])
  })).filter(o=>isFinite(o.latitude)&&isFinite(o.longitude)&&isFinite(o.x)&&isFinite(o.y));
}

async function loadCalibration(){
  try{
    const res = await fetch(CSV_URL, {cache:'no-store'});
    if(!res.ok) throw new Error('CSV introuvable');
    const txt = await res.text();
    const pts = parseCSV(txt);
    if(!pts.length) throw new Error('CSV vide');

    // Estimation robuste (m√©dianes)
    // centre image : essaye d‚Äôinf√©rer si pr√©sent, sinon secours
    calib.cx = calib.cx ?? 0.5 * (Math.min(...pts.map(p=>p.x)) + Math.max(...pts.map(p=>p.x)));
    calib.cy = calib.cy ?? 0.5 * (Math.min(...pts.map(p=>p.y)) + Math.max(...pts.map(p=>p.y)));

    const toRad = d=>d*Math.PI/180, toDeg = r=>r*180/Math.PI;
    const deltas = [];
    const scales = [];
    for(const p of pts){
      const dx = p.x - calib.cx;
      const dy = p.y - calib.cy;
      const r  = Math.hypot(dx,dy);
      const a  = Math.atan2(dx, -dy);  // 0 en haut, + sens horaire -> comme l‚Äôimage
      const lon = toRad(p.longitude);
      // a ‚âà lon - Œª0  ‚Üí Œª0 ‚âà lon - a
      deltas.push(((lon - a + Math.PI)%(2*Math.PI))-Math.PI);
      const colat = 90 - p.latitude; // degr√©s
      if(colat>0.001) scales.push(r / colat);
    }
    // m√©dianes
    const median = arr => (arr.sort((a,b)=>a-b)[Math.floor(arr.length/2)]);
    calib.lambda0 = toDeg(median(deltas));
    calib.S       = median(scales);
    calib.ready = true;
  }catch(err){
    console.warn('Calibrage: √©chec CSV ‚Üí on garde les valeurs de secours.', err);
    calib.ready = true; // on a des valeurs par d√©faut
  }
}

/* ========= PROJECTIONS ========= */
function azxyToLonLat(x,y){
  // pixel ‚Üí (lon,lat) sur l‚ÄôAEQD polaire
  const dx = x - calib.cx, dy = y - calib.cy;
  const r  = Math.hypot(dx,dy);
  const a  = Math.atan2(dx, -dy); // rad
  const lon = (a * 180/Math.PI) + calib.lambda0;
  const colat = r / calib.S;   // degr√©s
  const lat = 90 - colat;
  return [wrapLon(lon), clampLat(lat)];
}
function lonLatToAzxy(lon,lat){
  const colat = 90 - lat;      // degr√©s
  const r = calib.S * colat;
  const a = (lon - calib.lambda0) * Math.PI/180; // rad
  const x = calib.cx + r * Math.sin(a);
  const y = calib.cy - r * Math.cos(a);
  return [x,y];
}
function wrapLon(lon){ let L=((lon+180)%360+360)%360-180; return L; }
function clampLat(lat){ return Math.max(-90, Math.min(90, lat)); }

/* ========= STYLE MAPLIBRE ========= */
function styleWithImagery(key){
  const prov = providers[key] || providers.osm;
  return {
    version:8,
    sources:{
      imagery:{
        type:'raster',
        tiles:prov.tiles,
        tileSize:prov.tileSize,
        attribution:prov.attribution,
        minzoom:0, maxzoom:10
      },
      // image source seulement pour donner un rep√®re visuel (superpos√©),
      // mais on ne s‚Äôen sert PAS pour les calculs (on passe par le canvas)
      azimuthal:{
        type:'image',
        url: AZIMUTHAL_IMG_URL,
        coordinates:[
          [-180,  MERC_MAX],
          [ 180,  MERC_MAX],
          [ 180, -MERC_MAX],
          [-180, -MERC_MAX]
        ]
      }
    },
    layers:[
      { id:'imagery', type:'raster', source:'imagery',
        paint:{ 'raster-opacity': ['interpolate',['linear'],['zoom'], FADE_IN_IM_START,0, FADE_IN_IM_END,1 ] } },
      { id:'azimuthal', type:'raster', source:'azimuthal',
        paint:{ 'raster-opacity': ['interpolate',['linear'],['zoom'], 0,1, FADE_OUT_AZ_START,1, FADE_OUT_AZ_END,0 ] } }
    ]
  };
}

/* ========= APP ========= */
const map = new maplibregl.Map({
  container:'map',
  style: styleWithImagery('esri'),
  center:[0,30],
  zoom:2,
  maxZoom:18,
  pitch:0,
});
map.addControl(new maplibregl.NavigationControl({visualizePitch:true}),'top-left');
map.addControl(new maplibregl.ScaleControl({maxWidth:120,unit:'metric'}));
map.addControl(new maplibregl.AttributionControl({compact:true}));

const overlay = document.getElementById('overlay');
const ctx = overlay.getContext('2d');
const dbg = document.getElementById('dbg');
const img = new Image(); img.src = AZIMUTHAL_IMG_URL; img.crossOrigin = 'anonymous';
let lastLonLat = [0,0]; // dernier point vis√© en azimutal

function resizeOverlay(){
  overlay.width = overlay.clientWidth = map.getContainer().clientWidth;
  overlay.height = overlay.clientHeight = map.getContainer().clientHeight;
  drawOverlay();
}
function drawOverlay(){
  const w = overlay.width, h = overlay.height;
  ctx.clearRect(0,0,w,h);
  // tant que l‚Äôazimutale est visible (>0), on dessine l‚Äôimage en mode ¬´ contain ¬ª centr√©
  const z = map.getZoom();
  const azAlpha = fadeValue(z, 0, FADE_OUT_AZ_START, FADE_OUT_AZ_END);
  if(azAlpha<=0) return;
  ctx.globalAlpha = azAlpha;
  // on dessine l‚Äôimage √† l‚Äô√©chelle de la fen√™tre (simple rep√®re visuel)
  // (on garde l‚Äôaspect carr√© de l‚ÄôAEQD)
  const side = Math.min(w,h);
  const x = (w-side)/2, y = (h-side)/2;
  ctx.drawImage(img, x, y, side, side);

  // petit viseur au centre + point vis√©
  ctx.globalAlpha = .9;
  ctx.beginPath(); ctx.arc(w/2,h/2,4,0,Math.PI*2); ctx.stroke();
  const [mx,my] = lastMouse || [w/2,h/2];
  ctx.beginPath(); ctx.arc(mx,my,3,0,Math.PI*2); ctx.fill();
}
function fadeValue(z, base, z0, z1){
  if(z<=z0) return 1;
  if(z>=z1) return 0;
  const t = (z - z0) / (z1 - z0);
  return 1 - t;
}

let lastMouse = null;
overlay.addEventListener('mousemove', (e)=>{
  lastMouse = [e.offsetX, e.offsetY];
  // Convertit le pixel √©cran ‚Üí pixel image (si l‚Äôimage ¬´ contain ¬ª)
  const w = overlay.width, h = overlay.height;
  const side = Math.min(w,h);
  const x0 = (w-side)/2, y0 = (h-side)/2;
  const ix = (e.offsetX - x0) / side * calib.width;
  const iy = (e.offsetY - y0) / side * calib.height;
  if(ix>=0 && ix<=calib.width && iy>=0 && iy<=calib.height){
    lastLonLat = azxyToLonLat(ix, iy);
    dbg.textContent = `lon ${lastLonLat[0].toFixed(3)}¬∞, lat ${lastLonLat[1].toFixed(3)}¬∞`;
  } else {
    dbg.textContent = '';
  }
  drawOverlay();
});

// Quand on passe le seuil de bascule, on recentre la carte Mercator
let recentered = false;
map.on('zoom', ()=>{
  drawOverlay();
  const z = map.getZoom();
  if(z >= RECENTER_TRIGGER_Z && !recentered){
    recentered = true;
    map.easeTo({ center:lastLonLat, duration:800 });
  }
  if(z < RECENTER_TRIGGER_Z - 0.25){ // hyst√©r√©sis
    recentered = false;
  }
});
map.on('resize', resizeOverlay);
img.onload = drawOverlay;

// changement d‚Äôimagerie
document.getElementById('layerSel').addEventListener('change', e=>{
  map.setStyle(styleWithImagery(e.target.value));
});

// init
resizeOverlay();
loadCalibration().then(()=>{ drawOverlay(); });

</script>
</body>
</html>